# -*- coding: utf-8 -*-
"""sql_query_LLM .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XL4S0h25rBO6QZzGgOcRrnET8Ga7Rzd8

#Import libraries
"""

import warnings
warnings.filterwarnings("ignore")

from sqlalchemy import create_engine, text
from langchain_community.utilities import SQLDatabase
from langchain.chains import create_sql_query_chain
from langchain_community.llms import HuggingFacePipeline
from transformers import pipeline
import re

"""#Create the database manually"""

engine = create_engine("sqlite:///sample.db")
with engine.begin() as conn:
    conn.execute(text("DROP TABLE IF EXISTS sales"))
    conn.execute(text("""
        CREATE TABLE sales (
            id INTEGER PRIMARY KEY,
            product TEXT,
            amount INTEGER
        )
    """))
    conn.execute(text("""
        INSERT INTO sales (product, amount) VALUES
        ('Laptop', 1200),
        ('Phone', 800),
        ('Tablet', 600),
        ('Phone', 900),
        ('Laptop', 1500)
    """))

"""#Import the llm model"""

db = SQLDatabase(engine)
hf_pipeline = pipeline(
    "text-generation",
    model="defog/sqlcoder-7b-2",
    device=0,
    torch_dtype="auto",
    temperature=0.0,
    max_new_tokens=100,
    do_sample=False
)

llm = HuggingFacePipeline(pipeline=hf_pipeline)

"""# Create chain"""

chain = create_sql_query_chain(llm, db)

"""#Extract the output from the chain to plain text"""

def extract_sql(text):
    # Try ```sql fenced block
    m = re.search(r"```sql(.*?)```", text, flags=re.S|re.I)
    if m:
        return m.group(1).strip()
    # Try plain SELECT ... ;
    m = re.search(r"(select .*?);", text, flags=re.S|re.I)
    if m:
        return m.group(0).strip()
    return text.strip()

"""Ask the Question to Database

"""

question = "Which product has the highest total sales?"
raw_output = chain.invoke({"question": question})

# Extract clean SQL
sql = extract_sql(raw_output)
print("üîπ Generated SQL:\n", sql)

# 6. Run SQL safely
result = db.run(sql)
print("üîπ Result:\n", result)

"""#conclusion

In this project, we transformed a small sales dataset into a normalized relational database consisting of two tables, products and sales. The products table stores unique product details such as name and base price, while the sales table records individual transactions and links them back to the corresponding product. This structured schema provided a strong foundation for querying and analysis. To enable natural language interaction with the database, we integrated the system with the Hugging Face model defog/sqlcoder-7b-2 through a LangChain pipeline. This pipeline allows plain English questions, such as ‚ÄúWhich product has the highest total sales?‚Äù, to be automatically converted into executable SQL queries, which are then run against the SQLite database to return results. Using this approach, we discovered that Laptops contributed the highest revenue, Phones and Laptops showed variability in pricing, and Tablets were the least frequent and least profitable product. Overall, this project demonstrates how a small dataset can be structured, expanded, and leveraged through LangChain and Hugging Face LLMs to bridge the gap between natural language and SQL, making data exploration more accessible and intuitive.
"""

